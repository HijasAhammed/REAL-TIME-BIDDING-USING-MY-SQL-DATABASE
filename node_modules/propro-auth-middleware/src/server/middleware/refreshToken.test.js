const rateLimit = require("express-rate-limit");
const refreshToken = require("./refreshToken");

jest.mock("express-rate-limit");

describe("refreshLimiter", () => {
  it("should be a rate limiter middleware", () => {
    expect(rateLimit).toHaveBeenCalledWith({
      windowMs: 15 * 60 * 1000,
      max: 100,
      message:
        "Too many refresh requests from this IP, please try again after 15 minutes",
    });
  });

  it("should be exported as a middleware function", () => {
    expect(typeof refreshToken).toBe("function");
  });

  it("should use the rate limiter middleware", () => {
    const mockUse = jest.fn();
    const app = { use: mockUse };

    refreshToken(app);

    expect(mockUse).toHaveBeenCalledWith(rateLimit());
  });
});

describe("refreshTokenMiddleware", () => {
  const mockRequest = (refreshToken) => ({
    headers: { "x-refresh-token": refreshToken },
  });
  const mockResponse = () => {
    const res = {};
    res.status = jest.fn().mockReturnValue(res);
    res.json = jest.fn().mockReturnValue(res);
    return res;
  };
  const mockNext = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("should return 401 if no refresh token is provided", async () => {
    const req = mockRequest();
    const res = mockResponse();

    await refreshTokenMiddleware(req, res, mockNext);

    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.json).toHaveBeenCalledWith({
      error: "No refresh token provided",
    });
    expect(mockNext).not.toHaveBeenCalled();
  });

  it("should return 400 if refresh token has invalid format", async () => {
    const req = mockRequest("invalid-token");
    const res = mockResponse();

    await refreshTokenMiddleware(req, res, mockNext);

    expect(res.status).toHaveBeenCalledWith(400);
    expect(res.json).toHaveBeenCalledWith({
      error: "Invalid refresh token format",
    });
    expect(mockNext).not.toHaveBeenCalled();
  });

  it("should return 401 if unable to refresh token", async () => {
    const req = mockRequest("valid-token");
    const res = mockResponse();
    axios.post.mockRejectedValue({ response: { status: 401 } });

    await refreshTokenMiddleware(req, res, mockNext);

    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.json).toHaveBeenCalledWith({ error: "Unable to refresh token" });
    expect(mockNext).not.toHaveBeenCalled();
  });

  it("should return 500 if an error occurs while refreshing token", async () => {
    const req = mockRequest("valid-token");
    const res = mockResponse();
    axios.post.mockRejectedValue(new Error("Some error"));

    await refreshTokenMiddleware(req, res, mockNext);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({ error: "Error refreshing token" });
    expect(mockNext).not.toHaveBeenCalled();
  });

  it("should set new access token and call next if refresh token is valid", async () => {
    const req = mockRequest("valid-token");
    const res = mockResponse();
    axios.post.mockResolvedValue({
      data: { access_token: "new-access-token" },
    });

    await refreshTokenMiddleware(req, res, mockNext);

    expect(refreshTokenCache.has("valid-token")).toBe(true);
    expect(refreshTokenCache.get("valid-token")).toBe("new-access-token");
    expect(req.newAccessToken).toBe("new-access-token");
    expect(mockNext).toHaveBeenCalled();
  });

  it("should use cached access token and call next if refresh token is already cached", async () => {
    refreshTokenCache.set("valid-token", "cached-access-token");
    const req = mockRequest("valid-token");
    const res = mockResponse();

    await refreshTokenMiddleware(req, res, mockNext);

    expect(req.newAccessToken).toBe("cached-access-token");
    expect(mockNext).toHaveBeenCalled();
  });
});
