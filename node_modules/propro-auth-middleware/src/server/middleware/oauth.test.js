describe('Test Middleware', () => {
  // Middleware correctly verifies JWT token and sets user in request object
  const jwt = require('jsonwebtoken');
  const middleware = require('../middleware');

  jest.mock('jsonwebtoken');

  describe('Set user if the jwt is valid', () => {
    it('should set user in request object when JWT token is valid', () => {
      const req = {
        headers: {
          authorization: 'JWT validToken',
        },
      };
      const res = {};
      const next = jest.fn();
      const decode = { username: 'testUser' };
      jwt.verify.mockImplementation((token, secret, callback) => {
        callback(null, decode);
      });

      middleware(req, res, next);

      expect(req.user).toEqual(decode);
      expect(next).toHaveBeenCalled();
    });
  });

  // GET request to '/test-refresh-token' returns JSON with message and access token
  const request = require('supertest');
  const app = require('..');

  describe('return a message and an access token', () => {
    it('should return JSON with message and access token', async () => {
      const response = await request(app)
        .get('/test-refresh-token')
        .set('Authorization', 'JWT validToken');

      expect(response.status).toBe(200);
      expect(response.body.message).toBe('Access granted with a new token');
      expect(response.body.accessToken).toBeDefined();
    });
  });

  // GET request to '/auth' redirects to authorization server URL with correct parameters
  const request = require('supertest');
  const app = require('..');

  describe('redirect with correct parameter', () => {
    it('should redirect to authorization server URL with correct parameters', async () => {
      process.env.AUTH_URL = 'http://auth-server.com';
      process.env.CLIENT_ID = 'testClientId';
      process.env.REDIRECT_URI = 'http://client.com/callback';

      const response = await request(app).get('/auth');

      expect(response.status).toBe(302);
      expect(response.header.location).toBe(
        'http://auth-server.com/oauth/authorize?response_type=code&client_id=testClientId&redirect_uri=http%3A%2F%2Fclient.com%2Fcallback',
      );
    });
  });

  // Authorization header is missing or invalid
  const middleware = require('../middleware');

  describe('Set user to undefined on missing header', () => {
    it('should set user to undefined when authorization header is missing or invalid', () => {
      const req = {
        headers: {},
      };
      const res = {};
      const next = jest.fn();

      middleware(req, res, next);

      expect(req.user).toBeUndefined();
      expect(next).toHaveBeenCalled();
    });
  });

  // No authorization code received in '/callback' endpoint
  const request = require('supertest');
  const app = require('..');

  describe('Error when excchange code is received', () => {
    it('should return 400 when no authorization code is received', async () => {
      const response = await request(app).get('/callback');

      expect(response.status).toBe(400);
      expect(response.text).toBe('No code received');
    });
  });

  // Error occurs during token exchange in '/callback' endpoint
  const request = require('supertest');
  const axios = require('axios');
  const app = require('..');

  jest.mock('axios');

  describe('Error during token exchange', () => {
    it('should return 500 when error occurs during token exchange', async () => {
      const req = {
        query: {
          code: 'validCode',
        },
      };
      const res = {};
      axios.post.mockRejectedValue(new Error('Test error'));

      const response = await request(app).get('/callback').query(req.query);

      expect(response.status).toBe(500);
      expect(response.text).toBe('Internal Server Error');
    });
  });

  // GET request to '/callback' exchanges authorization code for access token and sets cookie
  it('should exchange authorization code for access token and set cookie', async () => {
    const req = {
      query: {
        code: 'authorizationCode',
      },
    };
    const res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
      redirect: jest.fn(),
      cookie: jest.fn(),
    };
    const tokenResponse = {
      data: {
        access_token: 'accessToken',
        refresh_token: 'refreshToken',
      },
    };
    axios.post.mockResolvedValue(tokenResponse);

    await callback(req, res);

    expect(axios.post).toHaveBeenCalledWith(
      `${process.env.AUTH_URL}/oauth/token`,
      qs.stringify({
        grant_type: 'authorization_code',
        code: req.query.code,
        redirect_uri: process.env.REDIRECT_URI,
        client_id: process.env.CLIENT_ID,
        client_secret: process.env.CLIENT_SECRET,
      }),
      {
        headers: {
          'Content-Type': 'application/json',
        },
      },
    );
    expect(res.cookie).toHaveBeenCalledWith(
      'token',
      tokenResponse.data.access_token,
      {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
      },
    );
    expect(res.redirect).toHaveBeenCalledWith(
      `${process.env.CLIENT_URL}/?access_token=${tokenResponse.data.access_token}&refresh_token=${tokenResponse.data.refresh_token}`,
    );
  });

  // Unauthorized user receives 401 status code
  it('should return 401 status code for unauthorized user', () => {
    const req = {};
    const res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };

    middleware(req, res);

    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.send).toHaveBeenCalledWith('Unauthorized');
  });

  // Invalid redirect URI returns error in '/auth' endpoint
  it('should return error for invalid redirect URI', () => {
    const req = {};
    const res = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn(),
    };
    const authServerUrl = `${process.env.AUTH_URL}/oauth/authorize`;
    const clientId = process.env.CLIENT_ID;
    const redirectUri = process.env.REDIRECT_URI;

    auth(req, res);

    expect(res.redirect).toHaveBeenCalledWith(
      `${authServerUrl}?response_type=code&client_id=${clientId}&redirect_uri=${encodeURIComponent(
        redirectUri,
      )}`,
    );
  });
});
