describe("isValid", () => {
  it("should return true when all required permissions are present", () => {
    const decodedToken = { permissions: ["user", "manageUsers"] };
    const requiredPermissions = ["user", "manageUsers"];

    const result = isValid(decodedToken, requiredPermissions);

    expect(result).toBe(true);
  });

  it("should return false when some required permissions are missing", () => {
    const decodedToken = { permissions: ["user"] };
    const requiredPermissions = ["user", "manageUsers"];

    const result = isValid(decodedToken, requiredPermissions);

    expect(result).toBe(false);
  });

  it("should return false when all required permissions are missing", () => {
    const decodedToken = { permissions: [] };
    const requiredPermissions = ["user", "manageUsers"];

    const result = isValid(decodedToken, requiredPermissions);

    expect(result).toBe(false);
  });

  it("should return true when no permissions are required", () => {
    const decodedToken = { permissions: ["user", "manageUsers"] };
    const requiredPermissions = [];

    const result = isValid(decodedToken, requiredPermissions);

    expect(result).toBe(true);
  });
});

describe("VerifyAccount", () => {
  // Verify that a valid access token is present in the request header and proceed with the verification process.
  it("should return a 401 error response when access token is not present in the request header", async () => {
    const req = { headers: {} };
    const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    const next = jest.fn();

    await VerifyAccount([])(req, res, next);

    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.json).toHaveBeenCalledWith({
      error: "Access token is required",
    });
    expect(next).not.toHaveBeenCalled();
  });

  // Verify that the account has all the required permissions and attach account info to the request object.
  it("should return a 403 error response when the account does not have all the required permissions", async () => {
    const requiredPermissions = ["user", "manageUsers"];
    const account = { id: "123", permissions: ["user"] };
    const req = { headers: { authorization: "Bearer token" }, account };
    const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    const next = jest.fn();

    await VerifyAccount(requiredPermissions)(req, res, next);

    expect(res.status).toHaveBeenCalledWith(403);
    expect(res.json).toHaveBeenCalledWith({
      error: "Insufficient permissions",
    });
    expect(next).not.toHaveBeenCalled();
  });

  // Verify that the function calls the next middleware function after successful verification.
  it("should call the next middleware function after successful verification", async () => {
    const requiredPermissions = ["user", "manageUsers"];
    const account = { id: "123", permissions: ["user", "manageUsers"] };
    const req = { headers: { authorization: "Bearer token" }, account };
    const res = { status: jest.fn(), json: jest.fn() };
    const next = jest.fn();

    await VerifyAccount(requiredPermissions)(req, res, next);

    expect(res.status).not.toHaveBeenCalled();
    expect(res.json).not.toHaveBeenCalled();
    expect(next).toHaveBeenCalled();
  });

  // Verify that the function returns a 500 error response when an unexpected error occurs during verification.
  it("should return a 500 error response when an unexpected error occurs during verification", async () => {
    const requiredPermissions = ["user", "manageUsers"];
    const req = { headers: { authorization: "Bearer token" } };
    const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    const next = jest.fn();

    await VerifyAccount(requiredPermissions)(req, res, next);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({ error: "Internal Server Error" });
    expect(next).not.toHaveBeenCalled();
  });

  // Verify that the function handles errors returned by the external API and returns a 401 error response when the access token is invalid or expired.
  it("should return a 401 error response when the access token is invalid or expired", async () => {
    const requiredPermissions = ["user", "manageUsers"];
    const req = { headers: { authorization: "Bearer token" } };
    const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    const next = jest.fn();

    axios.get.mockRejectedValueOnce({ response: { status: 401 } });

    await VerifyAccount(requiredPermissions)(req, res, next);

    expect(res.status).toHaveBeenCalledWith(401);
    expect(res.json).toHaveBeenCalledWith({
      error: "Invalid or expired access token",
    });
    expect(next).not.toHaveBeenCalled();
  });

  // Verify that the function handles errors returned by the external API and returns a 500 error response when an unexpected error occurs during API call.
  it("should return a 500 error response when an unexpected error occurs during API call", async () => {
    const requiredPermissions = ["user", "manageUsers"];
    const req = { headers: { authorization: "Bearer token" } };
    const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };
    const next = jest.fn();

    axios.get.mockRejectedValueOnce(new Error("API error"));

    await VerifyAccount(requiredPermissions)(req, res, next);

    expect(res.status).toHaveBeenCalledWith(500);
    expect(res.json).toHaveBeenCalledWith({ error: "Internal Server Error" });
    expect(next).not.toHaveBeenCalled();
  });

  // Verify that the function retrieves the user from cache when the token is already cached.
  it("should retrieve the user from cache when the token is already cached", async () => {
    const requiredPermissions = ["user", "manageUsers"];
    const account = { id: "123", permissions: ["user", "manageUsers"] };
    const accessToken = "token";
    const decoded = { ...account, accessToken };
    const req = { headers: { authorization: `Bearer ${accessToken}` } };
    const res = { status: jest.fn(), json: jest.fn() };
    const next = jest.fn();

    tokenCache.set(accessToken, decoded);

    await VerifyAccount(requiredPermissions)(req, res, next);

    expect(req.user).toEqual(decoded);
    expect(next).toHaveBeenCalled();
  });

  // Verify that the function retrieves the user from the external API when the token is not cached.
  it("should retrieve the user from the external API when the token is not cached", async () => {
    const requiredPermissions = ["user", "manageUsers"];
    const account = { id: "123", permissions: ["user", "manageUsers"] };
    const accessToken = "token";
    const decoded = { ...account, accessToken };
    const req = { headers: { authorization: `Bearer ${accessToken}` } };
    const res = { status: jest.fn(), json: jest.fn() };
    const next = jest.fn();

    axios.get.mockResolvedValueOnce({ data: decoded });

    await VerifyAccount(requiredPermissions)(req, res, next);

    expect(req.user).toEqual(decoded);
    expect(tokenCache.get(accessToken)).toEqual(decoded);
    expect(next).toHaveBeenCalled();
  });
});
